<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Laptop Viewer - Object Detection</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: #000;
            color: white;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .video-container {
            display: flex;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        
        .video-section {
            flex: 1;
            min-width: 300px;
        }
        
        video {
            width: 100%;
            max-width: 640px;
            height: auto;
            border: 2px solid #333;
            border-radius: 8px;
            background: #222;
        }
        
        canvas {
            width: 100%;
            max-width: 640px;
            height: auto;
            border: 2px solid #007bff;
            border-radius: 8px;
            background: #222;
        }
        
        .status {
            margin: 20px 0;
            padding: 15px;
            border-radius: 8px;
            font-weight: bold;
        }
        
        .status.info {
            background: #17a2b8;
        }
        
        .status.success {
            background: #28a745;
        }
        
        .status.error {
            background: #dc3545;
        }
        
        .status.warning {
            background: #ffc107;
            color: #000;
        }
        
        .controls {
            margin: 20px 0;
            text-align: center;
        }
        
        .btn {
            padding: 15px 30px;
            margin: 10px;
            font-size: 16px;
            border: none;
            border-radius: 8px;
            background: #007bff;
            color: white;
            cursor: pointer;
            display: inline-block;
            min-width: 120px;
        }
        
        .btn:disabled {
            background: #666;
            cursor: not-allowed;
        }
        
        .btn.success {
            background: #28a745;
        }
        
        .btn.danger {
            background: #dc3545;
        }
        
        #qrCode {
            text-align: center;
            margin: 20px 0;
        }
        
        #qrCode img {
            max-width: 256px;
            border: 2px solid #333;
            border-radius: 8px;
        }
        
        #log {
            text-align: left;
            background: #222;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            font-family: monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .detection-info {
            background: #333;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
        }
        
        .detection-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin: 10px 0;
        }
        
        .stat {
            background: #444;
            padding: 10px;
            border-radius: 4px;
            text-align: center;
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #007bff;
        }
        
        .stat-label {
            font-size: 12px;
            color: #ccc;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üíª Laptop Viewer - WebRTC Object Detection</h1>
        
        <div id="status" class="status info">
            Waiting for phone connection...
        </div>
        
        <div class="controls">
            <button id="startBtn" class="btn">Start Waiting</button>
            <button id="generateQRBtn" class="btn">Generate QR Code</button>
            <button id="toggleDetectionBtn" class="btn" disabled>Start Detection</button>
        </div>
        
        <div id="qrCode"></div>
        
        <div class="video-container">
            <div class="video-section">
                <h3>üì± Phone Stream</h3>
                <video id="remoteVideo" autoplay playsinline muted></video>
            </div>
            <div class="video-section">
                <h3>üéØ Object Detection</h3>
                <canvas id="detectionCanvas"></canvas>
            </div>
        </div>
        
        <div class="detection-info">
            <h3>Detection Statistics</h3>
            <div class="detection-stats">
                <div class="stat">
                    <div class="stat-value" id="fpsValue">0</div>
                    <div class="stat-label">FPS</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="objectsValue">0</div>
                    <div class="stat-label">Objects</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="latencyValue">0</div>
                    <div class="stat-label">Latency (ms)</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="confidenceValue">0</div>
                    <div class="stat-label">Avg Confidence</div>
                </div>
            </div>
        </div>
        
        <div id="log"></div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        class LaptopViewer {
            constructor() {
                this.remoteVideo = document.getElementById('remoteVideo');
                this.detectionCanvas = document.getElementById('detectionCanvas');
                this.ctx = this.detectionCanvas.getContext('2d');
                this.startBtn = document.getElementById('startBtn');
                this.generateQRBtn = document.getElementById('generateQRBtn');
                this.toggleDetectionBtn = document.getElementById('toggleDetectionBtn');
                this.statusDiv = document.getElementById('status');
                this.logDiv = document.getElementById('log');
                this.qrCodeDiv = document.getElementById('qrCode');
                
                this.socket = null;
                this.peerConnection = null;
                this.isDetectionActive = false;
                this.detectionInterval = null;
                this.stats = {
                    fps: 0,
                    objects: 0,
                    latency: 0,
                    confidence: 0
                };
                
                this.setupEventListeners();
            }
            
            setupEventListeners() {
                this.startBtn.addEventListener('click', () => this.startWaiting());
                this.generateQRBtn.addEventListener('click', () => this.generateQRCode());
                this.toggleDetectionBtn.addEventListener('click', () => this.toggleDetection());
            }
            
            startWaiting() {
                this.log('üöÄ Starting laptop viewer...');
                this.updateStatus('Connecting to server...', 'info');
                
                try {
                    this.socket = io({
                        transports: ['websocket', 'polling']
                    });
                    
                    this.socket.on('connect', () => {
                        this.log('‚úÖ Connected to server');
                        this.updateStatus('Waiting for phone connection...', 'info');
                        this.startBtn.disabled = true;
                        this.generateQRBtn.disabled = false;
                    });
                    
                    this.socket.on('disconnect', () => {
                        this.log('‚ùå Disconnected from server');
                        this.updateStatus('Disconnected from server', 'error');
                    });
                    
                    this.socket.on('phone-ready', () => {
                        this.log('üì± Phone is ready');
                        this.updateStatus('Phone connected, setting up stream...', 'info');
                    });
                    
                    this.socket.on('offer', (offer) => {
                        this.log('üì• Received offer from phone');
                        this.handleOffer(offer);
                    });
                    
                    this.socket.on('ice-candidate', (candidate) => {
                        this.log('üßä Received ICE candidate');
                        this.handleIceCandidate(candidate);
                    });
                    
                    this.socket.on('phone-disconnected', () => {
                        this.log('üì± Phone disconnected');
                        this.updateStatus('Phone disconnected', 'warning');
                        this.cleanup();
                    });
                    
                } catch (error) {
                    this.log('‚ùå Connection failed: ' + error.message);
                    this.updateStatus('Connection failed', 'error');
                }
            }
            
            async generateQRCode() {
                try {
                    this.log('üì± Generating QR code...');
                    const response = await fetch('/qr');
                    const data = await response.json();
                    
                    this.qrCodeDiv.innerHTML = `
                        <h3>üì± Scan with your phone:</h3>
                        <img src="${data.qrCode}" alt="QR Code">
                        <p>Or visit: <a href="${data.phoneUrl}" target="_blank">${data.phoneUrl}</a></p>
                    `;
                    
                    this.log('‚úÖ QR code generated');
                } catch (error) {
                    this.log('‚ùå QR code generation failed: ' + error.message);
                }
            }
            
            async handleOffer(offer) {
                try {
                    // Create RTCPeerConnection
                    this.peerConnection = new RTCPeerConnection({
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:stun1.l.google.com:19302' }
                        ]
                    });
                    
                    // Handle incoming stream
                    this.peerConnection.ontrack = (event) => {
                        this.log('üì∫ Received remote stream');
                        this.remoteVideo.srcObject = event.streams[0];
                        this.updateStatus('Phone stream active!', 'success');
                        this.toggleDetectionBtn.disabled = false;
                        this.setupDetectionCanvas();
                    };
                    
                    // Handle ICE candidates
                    this.peerConnection.onicecandidate = (event) => {
                        if (event.candidate) {
                            this.log('üßä Sending ICE candidate');
                            this.socket.emit('ice-candidate', event.candidate);
                        }
                    };
                    
                    // Handle connection state changes
                    this.peerConnection.onconnectionstatechange = () => {
                        const state = this.peerConnection.connectionState;
                        this.log(`üîó Connection state: ${state}`);
                        
                        if (state === 'connected') {
                            this.updateStatus('Connected to phone!', 'success');
                        } else if (state === 'disconnected' || state === 'failed') {
                            this.updateStatus('Connection lost', 'error');
                            this.cleanup();
                        }
                    };
                    
                    // Set remote description and create answer
                    await this.peerConnection.setRemoteDescription(offer);
                    const answer = await this.peerConnection.createAnswer();
                    await this.peerConnection.setLocalDescription(answer);
                    
                    this.log('üì§ Sending answer to phone');
                    this.socket.emit('answer', answer);
                    
                } catch (error) {
                    this.log('‚ùå Offer handling error: ' + error.message);
                }
            }
            
            async handleIceCandidate(candidate) {
                try {
                    if (this.peerConnection) {
                        await this.peerConnection.addIceCandidate(candidate);
                        this.log('‚úÖ ICE candidate added');
                    }
                } catch (error) {
                    this.log('‚ùå ICE candidate error: ' + error.message);
                }
            }
            
            setupDetectionCanvas() {
                this.remoteVideo.addEventListener('loadedmetadata', () => {
                    this.detectionCanvas.width = this.remoteVideo.videoWidth;
                    this.detectionCanvas.height = this.remoteVideo.videoHeight;
                    this.log(`üìê Canvas size: ${this.detectionCanvas.width}x${this.detectionCanvas.height}`);
                });
            }
            
            toggleDetection() {
                if (this.isDetectionActive) {
                    this.stopDetection();
                } else {
                    this.startDetection();
                }
            }
            
            startDetection() {
                this.isDetectionActive = true;
                this.toggleDetectionBtn.textContent = 'Stop Detection';
                this.toggleDetectionBtn.className = 'btn danger';
                this.log('üéØ Starting real-time object detection...');
                
                // Real AI detection - slower but more realistic for processing
                this.detectionInterval = setInterval(() => {
                    this.processFrame();
                }, 500); // 2 FPS for real AI processing
            }
            
            stopDetection() {
                this.isDetectionActive = false;
                this.toggleDetectionBtn.textContent = 'Start Detection';
                this.toggleDetectionBtn.className = 'btn';
                this.log('üõë Stopping object detection...');
                
                if (this.detectionInterval) {
                    clearInterval(this.detectionInterval);
                    this.detectionInterval = null;
                }
                
                this.ctx.clearRect(0, 0, this.detectionCanvas.width, this.detectionCanvas.height);
            }
            
            async processFrame() {
                if (!this.remoteVideo.videoWidth || !this.remoteVideo.videoHeight) return;
                
                try {
                    // Draw video frame to canvas for capture
                    this.ctx.drawImage(this.remoteVideo, 0, 0, this.detectionCanvas.width, this.detectionCanvas.height);
                    
                    // Convert canvas to base64 image data
                    const imageData = this.detectionCanvas.toDataURL('image/jpeg', 0.8);
                    
                    // Send frame to server for real AI detection
                    const startTime = Date.now();
                    const response = await fetch('/detect', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ 
                            image: imageData,
                            timestamp: startTime
                        })
                    });
                    
                    if (response.ok) {
                        const result = await response.json();
                        const latency = Date.now() - startTime;
                        
                        // Draw real detection results
                        this.drawDetections(result.detections || []);
                        
                        // Update stats with real data
                        this.stats.objects = result.detections ? result.detections.length : 0;
                        this.stats.latency = latency;
                        this.stats.confidence = result.detections && result.detections.length > 0 
                            ? result.detections.reduce((sum, det) => sum + (det.score || det.confidence || 0), 0) / result.detections.length 
                            : 0;
                        this.stats.fps = Math.round(1000 / Math.max(latency, 100)); // Estimate FPS
                        
                        this.log(`üéØ Detected ${this.stats.objects} objects (${latency}ms)`);
                    } else {
                        this.log('‚ùå Detection request failed');
                    }
                    
                } catch (error) {
                    this.log('‚ùå Frame processing error: ' + error.message);
                }
                
                // Update stats display
                this.updateStats();
            }
            
            simulateDetection() {
                // Fallback simulation for when server detection fails
                const detections = [
                    {
                        class: 'person',
                        confidence: 0.85,
                        bbox: [100, 50, 200, 300]
                    },
                    {
                        class: 'phone',
                        confidence: 0.72,
                        bbox: [300, 100, 80, 150]
                    }
                ];
                
                this.drawDetections(detections);
                this.stats.objects = detections.length;
                this.stats.confidence = detections.reduce((sum, det) => sum + det.confidence, 0) / detections.length;
            }
            
            drawDetections(detections) {
                // Clear previous detections
                this.ctx.clearRect(0, 0, this.detectionCanvas.width, this.detectionCanvas.height);
                
                // Redraw video frame
                this.ctx.drawImage(this.remoteVideo, 0, 0, this.detectionCanvas.width, this.detectionCanvas.height);
                
                // Set drawing style
                this.ctx.strokeStyle = '#00ff00';
                this.ctx.lineWidth = 3;
                this.ctx.font = '16px Arial';
                this.ctx.fillStyle = '#00ff00';
                this.ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                this.ctx.shadowOffsetX = 1;
                this.ctx.shadowOffsetY = 1;
                
                detections.forEach(detection => {
                    // Handle both old format (for simulation) and new format (from API)
                    let x, y, w, h, label, confidence;
                    
                    if (detection.bbox && detection.bbox.length === 4) {
                        if (detection.label && detection.score !== undefined) {
                            // New API format: normalized coordinates [xmin, ymin, xmax, ymax]
                            const [xmin, ymin, xmax, ymax] = detection.bbox;
                            x = xmin * this.detectionCanvas.width;
                            y = ymin * this.detectionCanvas.height;
                            w = (xmax - xmin) * this.detectionCanvas.width;
                            h = (ymax - ymin) * this.detectionCanvas.height;
                            label = detection.label;
                            confidence = detection.score;
                        } else {
                            // Old simulation format: [x, y, w, h]
                            [x, y, w, h] = detection.bbox;
                            label = detection.class || 'object';
                            confidence = detection.confidence || 0.5;
                        }
                    } else {
                        return; // Skip invalid detections
                    }
                    
                    // Draw bounding box
                    this.ctx.strokeRect(x, y, w, h);
                    
                    // Draw label background
                    const text = `${label} ${(confidence * 100).toFixed(0)}%`;
                    const textMetrics = this.ctx.measureText(text);
                    const textWidth = textMetrics.width;
                    const textHeight = 20;
                    
                    this.ctx.fillStyle = 'rgba(0, 255, 0, 0.8)';
                    this.ctx.fillRect(x, y - textHeight - 2, textWidth + 10, textHeight + 4);
                    
                    // Draw label text
                    this.ctx.fillStyle = '#000000';
                    this.ctx.fillText(text, x + 5, y - 5);
                });
                
                // Reset shadow
                this.ctx.shadowColor = 'transparent';
            }
            
            updateStats() {
                // Update display with current stats (no more fake data)
                document.getElementById('fpsValue').textContent = this.stats.fps;
                document.getElementById('objectsValue').textContent = this.stats.objects;
                document.getElementById('latencyValue').textContent = this.stats.latency;
                document.getElementById('confidenceValue').textContent = (this.stats.confidence * 100).toFixed(0) + '%';
            }
            
            cleanup() {
                if (this.peerConnection) {
                    this.peerConnection.close();
                    this.peerConnection = null;
                }
                
                this.remoteVideo.srcObject = null;
                this.toggleDetectionBtn.disabled = true;
                this.stopDetection();
            }
            
            updateStatus(message, type) {
                this.statusDiv.textContent = message;
                this.statusDiv.className = `status ${type}`;
            }
            
            log(message) {
                const timestamp = new Date().toLocaleTimeString();
                const logEntry = `[${timestamp}] ${message}`;
                console.log(logEntry);
                
                const logElement = document.createElement('div');
                logElement.textContent = logEntry;
                this.logDiv.appendChild(logElement);
                this.logDiv.scrollTop = this.logDiv.scrollHeight;
            }
        }
        
        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            new LaptopViewer();
        });
    </script>
</body>
</html>
